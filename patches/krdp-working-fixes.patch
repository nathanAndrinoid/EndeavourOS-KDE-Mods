diff --git a/src/InputHandler.cpp b/src/InputHandler.cpp
index 108ea32..49f245c 100644
--- a/src/InputHandler.cpp
+++ b/src/InputHandler.cpp
@@ -5,6 +5,8 @@
 #include "InputHandler.h"
 
 #include <QKeyEvent>
+#include <QStringList>
+#include <QtGlobal>
 
 #include <xkbcommon/xkbcommon.h>
 
@@ -14,6 +16,102 @@
 
 namespace KRdp
 {
+namespace
+{
+bool inputLoggingEnabled()
+{
+    static const bool enabled = [] {
+        if (!qEnvironmentVariableIsSet("KRDP_LOG_INPUT")) {
+            return false;
+        }
+
+        const QString value = QString::fromLatin1(qgetenv("KRDP_LOG_INPUT")).trimmed().toLower();
+        return value != QLatin1String("0")
+            && value != QLatin1String("false")
+            && value != QLatin1String("no")
+            && value != QLatin1String("off");
+    }();
+    return enabled;
+}
+
+bool invertTouchpadScroll()
+{
+    if (!qEnvironmentVariableIsSet("KRDP_TOUCHPAD_SCROLL_INVERT")) {
+        return true;
+    }
+
+    const QString value = QString::fromLatin1(qgetenv("KRDP_TOUCHPAD_SCROLL_INVERT")).trimmed().toLower();
+    return value != QLatin1String("0")
+        && value != QLatin1String("false")
+        && value != QLatin1String("no")
+        && value != QLatin1String("off");
+}
+
+QString pointerFlagsDescription(uint16_t flags)
+{
+    QStringList parts;
+
+    if (flags & PTR_FLAGS_MOVE) {
+        parts << QStringLiteral("MOVE");
+    }
+    if (flags & PTR_FLAGS_DOWN) {
+        parts << QStringLiteral("DOWN");
+    }
+    if (flags & PTR_FLAGS_BUTTON1) {
+        parts << QStringLiteral("BTN1");
+    }
+    if (flags & PTR_FLAGS_BUTTON2) {
+        parts << QStringLiteral("BTN2");
+    }
+    if (flags & PTR_FLAGS_BUTTON3) {
+        parts << QStringLiteral("BTN3");
+    }
+    if (flags & PTR_FLAGS_WHEEL || flags & PTR_FLAGS_HWHEEL) {
+        auto axis = flags & WheelRotationMask;
+        if (axis & PTR_FLAGS_WHEEL_NEGATIVE) {
+            axis = (~axis & WheelRotationMask) + 1;
+        }
+        axis *= flags & PTR_FLAGS_WHEEL_NEGATIVE ? 1 : -1;
+
+        if (flags & PTR_FLAGS_WHEEL) {
+            parts << QStringLiteral("VWHEEL(%1)").arg(axis);
+        }
+        if (flags & PTR_FLAGS_HWHEEL) {
+            parts << QStringLiteral("HWHEEL(%1)").arg(axis);
+        }
+    }
+
+    if (parts.isEmpty()) {
+        parts << QStringLiteral("NONE");
+    }
+
+    return parts.join(QLatin1Char('|'));
+}
+
+QString xPointerFlagsDescription(uint16_t flags)
+{
+    QStringList parts;
+
+    if (flags & PTR_FLAGS_MOVE) {
+        parts << QStringLiteral("MOVE");
+    }
+    if (flags & PTR_XFLAGS_DOWN) {
+        parts << QStringLiteral("DOWN");
+    }
+    if (flags & PTR_XFLAGS_BUTTON1) {
+        parts << QStringLiteral("XBTN1");
+    }
+    if (flags & PTR_XFLAGS_BUTTON2) {
+        parts << QStringLiteral("XBTN2");
+    }
+
+    if (parts.isEmpty()) {
+        parts << QStringLiteral("NONE");
+    }
+
+    return parts.join(QLatin1Char('|'));
+}
+}
 
 BOOL inputSynchronizeEvent(rdpInput *input, uint32_t flags)
 {
@@ -37,6 +135,17 @@ BOOL inputMouseEvent(rdpInput *input, uint16_t flags, uint16_t x, uint16_t y)
     return FALSE;
 }
 
+BOOL inputRelMouseEvent(rdpInput *input, uint16_t flags, int16_t xDelta, int16_t yDelta)
+{
+    auto context = reinterpret_cast<PeerContext *>(input->context);
+
+    if (context->inputHandler->relativeMouseEvent(xDelta, yDelta, flags)) {
+        return TRUE;
+    }
+
+    return FALSE;
+}
+
 BOOL inputExtendedMouseEvent(rdpInput *input, uint16_t flags, uint16_t x, uint16_t y)
 {
     auto context = reinterpret_cast<PeerContext *>(input->context);
@@ -73,6 +183,8 @@ class KRDP_NO_EXPORT InputHandler::Private
 {
 public:
     RdpConnection *session;
     rdpInput *input;
+    QPointF lastMousePosition{0, 0};
+    QPointF relativePointerPos{0, 0};
 };
 
 InputHandler::InputHandler(KRdp::RdpConnection *session)
@@ -94,6 +204,7 @@ void InputHandler::initialize(rdpInput *input)
     d->input = input;
     input->SynchronizeEvent = inputSynchronizeEvent;
     input->MouseEvent = inputMouseEvent;
+    input->RelMouseEvent = inputRelMouseEvent;
     input->ExtendedMouseEvent = inputExtendedMouseEvent;
     input->KeyboardEvent = inputKeyboardEvent;
     input->UnicodeKeyboardEvent = inputUnicodeKeyboardEvent;
@@ -101,12 +212,19 @@ void InputHandler::initialize(rdpInput *input)
 
 bool InputHandler::synchronizeEvent(uint32_t /*flags*/)
 {
+    if (inputLoggingEnabled()) {
+        qCDebug(KRDP) << "Input sync event";
+    }
     // TODO: This syncs caps/num/scroll lock keys, do we actually want to?
     return true;
 }
 
 bool InputHandler::mouseEvent(uint16_t x, uint16_t y, uint16_t flags)
 {
+    if (inputLoggingEnabled()) {
+        qCDebug(KRDP) << "Input mouse event:" << pointerFlagsDescription(flags) << "x=" << x << "y=" << y << "flags=0x" << Qt::hex << flags;
+    }
+
     QPointF position = QPointF(x, y);
 
     // Track last known mouse position for wheel events from clients
@@ -152,6 +270,10 @@ bool InputHandler::mouseEvent(uint16_t x, uint16_t y, uint16_t flags)
 
 bool InputHandler::extendedMouseEvent(uint16_t x, uint16_t y, uint16_t flags)
 {
+    if (inputLoggingEnabled()) {
+        qCDebug(KRDP) << "Input extended mouse event:" << xPointerFlagsDescription(flags) << "x=" << x << "y=" << y << "flags=0x" << Qt::hex << flags;
+    }
+
     if (flags & PTR_FLAGS_MOVE) {
         return mouseEvent(x, y, PTR_FLAGS_MOVE);
     }
@@ -177,8 +299,76 @@ bool InputHandler::extendedMouseEvent(uint16_t x, uint16_t y, uint16_t flags)
     return true;
 }
 
+bool InputHandler::relativeMouseEvent(int16_t xDelta, int16_t yDelta, uint16_t flags)
+{
+    if (inputLoggingEnabled()) {
+        qCDebug(KRDP) << "Input relative mouse event:" << pointerFlagsDescription(flags) << "dx=" << xDelta << "dy=" << yDelta << "flags=0x" << Qt::hex << flags;
+    }
+
+    if (flags & PTR_FLAGS_WHEEL || flags & PTR_FLAGS_HWHEEL) {
+        auto axis = flags & WheelRotationMask;
+        if (axis & PTR_FLAGS_WHEEL_NEGATIVE) {
+            axis = (~axis & WheelRotationMask) + 1;
+        }
+        axis *= flags & PTR_FLAGS_WHEEL_NEGATIVE ? 1 : -1;
+        if (flags & PTR_FLAGS_WHEEL) {
+            auto event = std::make_shared<QWheelEvent>(d->relativePointerPos,
+                                                       QPointF{},
+                                                       QPoint{},
+                                                       QPoint{0, axis},
+                                                       Qt::NoButton,
+                                                       Qt::KeyboardModifiers{},
+                                                       Qt::NoScrollPhase,
+                                                       false);
+            Q_EMIT inputEvent(event);
+        }
+        if (flags & PTR_FLAGS_HWHEEL) {
+            const int horizontalAxis = invertTouchpadScroll() ? axis : -axis;
+            auto event = std::make_shared<QWheelEvent>(d->relativePointerPos,
+                                                       QPointF{},
+                                                       QPoint{},
+                                                       QPoint{horizontalAxis, 0},
+                                                       Qt::NoButton,
+                                                       Qt::KeyboardModifiers{},
+                                                       Qt::NoScrollPhase,
+                                                       false);
+            Q_EMIT inputEvent(event);
+        }
+        return true;
+    }
+
+    if (flags & PTR_FLAGS_MOVE) {
+        d->relativePointerPos += QPointF(xDelta, yDelta);
+    }
+
+    Qt::MouseButton button = Qt::NoButton;
+    if (flags & PTR_FLAGS_BUTTON1) {
+        button = Qt::LeftButton;
+    } else if (flags & PTR_FLAGS_BUTTON2) {
+        button = Qt::RightButton;
+    } else if (flags & PTR_FLAGS_BUTTON3) {
+        button = Qt::MiddleButton;
+    }
+
+    std::shared_ptr<QMouseEvent> event;
+    if (flags & PTR_FLAGS_DOWN) {
+        event = std::make_shared<QMouseEvent>(QEvent::MouseButtonPress, d->relativePointerPos, QPointF{}, button, button, Qt::NoModifier);
+    } else if (flags & PTR_FLAGS_MOVE) {
+        event = std::make_shared<QMouseEvent>(QEvent::MouseMove, d->relativePointerPos, QPointF{}, button, button, Qt::NoModifier);
+    } else {
+        event = std::make_shared<QMouseEvent>(QEvent::MouseButtonRelease, d->relativePointerPos, QPointF{}, button, button, Qt::NoModifier);
+    }
+    Q_EMIT inputEvent(event);
+
+    return true;
+}
+
 bool InputHandler::keyboardEvent(uint16_t code, uint16_t flags)
 {
+    if (inputLoggingEnabled()) {
+        qCDebug(KRDP) << "Input keyboard event: scancode=" << code << "flags=0x" << Qt::hex << flags;
+    }
+
     auto virtualCode = GetVirtualKeyCodeFromVirtualScanCode(flags & KBD_FLAGS_EXTENDED ? code | KBDEXT : code, 4);
     virtualCode = flags & KBD_FLAGS_EXTENDED ? virtualCode | KBDEXT : virtualCode;
 
@@ -194,6 +384,10 @@ bool InputHandler::keyboardEvent(uint16_t code, uint16_t flags)
 
 bool InputHandler::unicodeKeyboardEvent(uint16_t code, uint16_t flags)
 {
+    if (inputLoggingEnabled()) {
+        qCDebug(KRDP) << "Input unicode keyboard event: codepoint=U+" << Qt::hex << code << "flags=0x" << flags;
+    }
+
     auto text = QString(QChar::fromUcs2(code));
     auto keysym = xkb_utf32_to_keysym(text.toUcs4().first());
     if (!keysym) {
diff --git a/src/InputHandler.h b/src/InputHandler.h
index 0b139e4..0a660b1 100644
--- a/src/InputHandler.h
+++ b/src/InputHandler.h
@@ -49,6 +49,7 @@ private:
     // handler.
     friend BOOL inputSynchronizeEvent(rdpInput *, uint32_t);
     friend BOOL inputMouseEvent(rdpInput *, uint16_t, uint16_t, uint16_t);
+    friend BOOL inputRelMouseEvent(rdpInput *, uint16_t, int16_t, int16_t);
     friend BOOL inputExtendedMouseEvent(rdpInput *, uint16_t, uint16_t, uint16_t);
     friend BOOL inputKeyboardEvent(rdpInput *, uint16_t, uint8_t);
     friend BOOL inputUnicodeKeyboardEvent(rdpInput *, uint16_t, uint16_t);
@@ -67,6 +68,7 @@ private:
      * \param flags Mouse button state and other flags.
      */
     bool mouseEvent(uint16_t x, uint16_t y, uint16_t flags);
+    bool relativeMouseEvent(int16_t xDelta, int16_t yDelta, uint16_t flags);
     bool extendedMouseEvent(uint16_t x, uint16_t y, uint16_t flags);
     bool keyboardEvent(uint16_t code, uint16_t flags);
     bool unicodeKeyboardEvent(uint16_t code, uint16_t flags);
diff --git a/src/PlasmaScreencastV1Session.cpp b/src/PlasmaScreencastV1Session.cpp
index 1b11424..e9161e0 100644
--- a/src/PlasmaScreencastV1Session.cpp
+++ b/src/PlasmaScreencastV1Session.cpp
@@ -174,9 +174,24 @@ void PlasmaScreencastV1Session::start()
 {
     if (auto vm = virtualMonitor()) {
         d->request = d->m_screencasting.createVirtualMonitorStream(vm->name, vm->size, vm->dpr, Screencasting::Metadata);
-    } else if (!activeStream()) {
+    } else if (activeStream() < 0) {
         d->request = d->m_screencasting.createWorkspaceStream(Screencasting::Metadata);
+    } else {
+        const auto screens = qGuiApp->screens();
+        if (activeStream() >= screens.size()) {
+            qCWarning(KRDP) << "Requested monitor index" << activeStream() << "is out of range; falling back to workspace stream";
+            d->request = d->m_screencasting.createWorkspaceStream(Screencasting::Metadata);
+        } else {
+            d->request = d->m_screencasting.createOutputStream(screens.at(activeStream()), Screencasting::Metadata);
+        }
+    }
+
+    if (!d->request) {
+        qCWarning(KRDP) << "Failed to create Plasma screencast request";
+        Q_EMIT error();
+        return;
     }
+
     connect(d->request, &ScreencastingStream::failed, this, &PlasmaScreencastV1Session::error);
     connect(d->request, &ScreencastingStream::created, this, [this](uint nodeId) {
         qCDebug(KRDP) << "Started Plasma session";
diff --git a/src/PortalSession.cpp b/src/PortalSession.cpp
index d6a1c50..6a1c505 100644
--- a/src/PortalSession.cpp
+++ b/src/PortalSession.cpp
@@ -8,6 +8,7 @@
 #include <QMimeData>
 #include <QMouseEvent>
 #include <QQueue>
+#include <QtGlobal>
 
 #include <linux/input.h>
 
@@ -26,6 +27,47 @@ using namespace Qt::StringLiterals;
 namespace KRdp
 {
 
+namespace
+{
+bool invertTouchpadScroll()
+{
+    if (!qEnvironmentVariableIsSet("KRDP_TOUCHPAD_SCROLL_INVERT")) {
+        return true;
+    }
+
+    const QString value = QString::fromLatin1(qgetenv("KRDP_TOUCHPAD_SCROLL_INVERT")).trimmed().toLower();
+    return value != QLatin1String("0") && value != QLatin1String("false") && value != QLatin1String("no") && value != QLatin1String("off");
+}
+
+double touchpadScrollScale()
+{
+    bool ok = false;
+    const QString value = QString::fromLatin1(qgetenv("KRDP_TOUCHPAD_SCROLL_SCALE")).trimmed();
+    if (!value.isEmpty()) {
+        const double parsed = value.toDouble(&ok);
+        if (ok && parsed > 0.0) {
+            return parsed;
+        }
+    }
+
+    return 0.35;
+}
+
+double mouseScrollScale()
+{
+    bool ok = false;
+    const QString value = QString::fromLatin1(qgetenv("KRDP_MOUSE_SCROLL_SCALE")).trimmed();
+    if (!value.isEmpty()) {
+        const double parsed = value.toDouble(&ok);
+        if (ok && parsed > 0.0) {
+            return parsed;
+        }
+    }
+
+    return 3.0;
+}
+}
+
 static const QString dbusService = QStringLiteral("org.freedesktop.portal.Desktop");
 static const QString dbusPath = QStringLiteral("/org/freedesktop/portal/desktop");
 static const QString dbusRequestInterface = QStringLiteral("org.freedesktop.portal.Request");
@@ -82,6 +124,8 @@ public:
     bool ignoreNextSystemClipboardChange = false;
 
     QDBusObjectPath sessionPath;
+    int pendingDiscreteWheelX = 0;
+    int pendingDiscreteWheelY = 0;
 };
 
 QString createHandleToken()
@@ -127,6 +171,13 @@ PortalSession::PortalSession()
 
 PortalSession::~PortalSession()
 {
+    const QString sessionPath = d->sessionPath.path();
+    const bool hasValidSessionPath = !sessionPath.isEmpty() && sessionPath != QStringLiteral("/");
+    if (!hasValidSessionPath) {
+        qCDebug(KRDP) << "Closing Freedesktop Portal Session without valid session path";
+        return;
+    }
+
     // Make sure to clear any modifier keys that were pressed when the session closed, otherwise
     // we risk those keys getting stuck and the original session becoming unusable.
     for (auto keycode : {KEY_LEFTCTRL, KEY_RIGHTCTRL, KEY_LEFTSHIFT, KEY_RIGHTSHIFT, KEY_LEFTALT, KEY_RIGHTALT, KEY_LEFTMETA, KEY_RIGHTMETA}) {
@@ -134,7 +185,7 @@ PortalSession::~PortalSession()
         call.waitForFinished();
     }
 
-    auto closeMessage = QDBusMessage::createMethodCall(dbusService, d->sessionPath.path(), dbusSessionInterface, QStringLiteral("Close"));
+    auto closeMessage = QDBusMessage::createMethodCall(dbusService, sessionPath, dbusSessionInterface, QStringLiteral("Close"));
     QDBusConnection::sessionBus().asyncCall(closeMessage);
 
     qCDebug(KRDP) << "Closing Freedesktop Portal Session";
@@ -184,13 +238,75 @@ void PortalSession::sendEvent(const std::shared_ptr<QEvent> &event)
     }
     case QEvent::Wheel: {
         auto we = std::static_pointer_cast<QWheelEvent>(event);
-        auto delta = we->angleDelta();
-        if (delta.y() != 0) {
-            d->remoteInterface->NotifyPointerAxisDiscrete(d->sessionPath, QVariantMap{}, 0 /* Vertical */, delta.y() / 120);
-        }
-        if (delta.x() != 0) {
-            d->remoteInterface->NotifyPointerAxisDiscrete(d->sessionPath, QVariantMap{}, 1 /* Horizontal */, delta.x() / 120);
-        }
+        const auto delta = we->angleDelta();
+        const auto pixelDelta = we->pixelDelta();
+        const auto position = we->position();
+        const bool hasPixelDelta = !pixelDelta.isNull();
+        const bool hasAngleDelta = !delta.isNull();
+        const bool coarseVertical = (delta.y() == 0) || ((delta.y() % 120) == 0);
+        const bool coarseHorizontal = (delta.x() == 0) || ((delta.x() % 120) == 0);
+        const bool isCoarseWheel = !hasPixelDelta && coarseVertical && coarseHorizontal;
+
+        QVariantMap smoothOptions;
+        if (we->phase() == Qt::ScrollEnd) {
+            smoothOptions.insert(QStringLiteral("finish"), true);
+        }
+
+        // Forward smooth deltas for high-resolution wheel/touchpad input.
+        double dx = 0.0;
+        double dy = 0.0;
+        bool sendSmoothAxis = false;
+        if (hasPixelDelta) {
+            dx = pixelDelta.x();
+            dy = pixelDelta.y();
+            sendSmoothAxis = true;
+        } else if (hasAngleDelta && !isCoarseWheel) {
+            dx = static_cast<double>(delta.x());
+            dy = static_cast<double>(delta.y());
+            sendSmoothAxis = true;
+        }
+        const bool likelyTouchpad = sendSmoothAxis
+            && qFuzzyIsNull(position.x())
+            && qFuzzyIsNull(position.y())
+            && qAbs(delta.x()) < 120
+            && qAbs(delta.y()) < 120;
+        if (sendSmoothAxis) {
+            if (likelyTouchpad) {
+                const double scale = touchpadScrollScale();
+                dx *= scale;
+                dy *= scale;
+                if (invertTouchpadScroll()) {
+                    dx = -dx;
+                    dy = -dy;
+                }
+            } else {
+                const double scale = mouseScrollScale();
+                dx *= scale;
+                dy *= scale;
+            }
+        }
+        if (sendSmoothAxis && (dx != 0.0 || dy != 0.0 || smoothOptions.contains(QStringLiteral("finish")))) {
+            d->remoteInterface->NotifyPointerAxis(d->sessionPath, smoothOptions, dx, dy);
+        }
+
+        if (!likelyTouchpad) {
+            const double scale = mouseScrollScale();
+            // Accumulate sub-120 angle deltas so wheel scrolling still works for
+            // clients that send high-resolution ticks.
+            d->pendingDiscreteWheelY += qRound(delta.y() * scale);
+            const int verticalSteps = d->pendingDiscreteWheelY / 120;
+            if (verticalSteps != 0) {
+                d->remoteInterface->NotifyPointerAxisDiscrete(d->sessionPath, QVariantMap{}, 0 /* Vertical */, verticalSteps);
+                d->pendingDiscreteWheelY -= verticalSteps * 120;
+            }
+
+            d->pendingDiscreteWheelX += qRound(delta.x() * scale);
+            const int horizontalSteps = d->pendingDiscreteWheelX / 120;
+            if (horizontalSteps != 0) {
+                d->remoteInterface->NotifyPointerAxisDiscrete(d->sessionPath, QVariantMap{}, 1 /* Horizontal */, horizontalSteps);
+                d->pendingDiscreteWheelX -= horizontalSteps * 120;
+            }
+        }
         break;
     }
     case QEvent::KeyPress:
diff --git a/src/RdpConnection.cpp b/src/RdpConnection.cpp
index 775aa84..2cda49e 100644
--- a/src/RdpConnection.cpp
+++ b/src/RdpConnection.cpp
@@ -9,6 +9,7 @@
 
 #include "RdpConnection.h"
 
+#include <algorithm>
 #include <filesystem>
 #include <optional>
 
@@ -18,6 +19,7 @@
 #include <QStandardPaths>
 #include <QTcpSocket>
 #include <QThread>
+#include <QtGlobal>
 
 #include <freerdp/channels/wtsvc.h>
 #include <freerdp/freerdp.h>
@@ -144,6 +146,63 @@ static int pamAuthenticate(const QString &user, const QString &password)
     return 1;
 }
 
+static QString normalizeLoginName(QString userName)
+{
+    userName = userName.trimmed();
+
+    // Some clients send DOMAIN\\user or DOMAIN/user.
+    const int separatorIndex = std::max(userName.lastIndexOf(u'\\'), userName.lastIndexOf(u'/'));
+    if (separatorIndex >= 0 && separatorIndex + 1 < userName.size()) {
+        userName = userName.mid(separatorIndex + 1);
+    }
+
+    return userName.trimmed();
+}
+
+static bool matchesLoginName(const QString &actualName, const QString &configuredName)
+{
+    if (configuredName.isEmpty()) {
+        return false;
+    }
+
+    if (actualName.compare(configuredName, Qt::CaseInsensitive) == 0) {
+        return true;
+    }
+
+    // Some clients send user@domain. Accept when the local part matches.
+    const int atSignIndex = actualName.indexOf(u'@');
+    if (atSignIndex > 0) {
+        const QStringView localPart = QStringView(actualName).left(atSignIndex);
+        if (localPart.compare(configuredName, Qt::CaseInsensitive) == 0) {
+            return true;
+        }
+    }
+
+    return false;
+}
+
+static QString authIdentityString(const UINT16 *value, ULONG length)
+{
+    if (!value || length == 0) {
+        return {};
+    }
+
+    return QString::fromUtf16(reinterpret_cast<const char16_t *>(value), static_cast<qsizetype>(length));
+}
+
+static bool nlaEnabledFromEnvironment()
+{
+    if (!qEnvironmentVariableIsSet("KRDP_ENABLE_NLA")) {
+        return false;
+    }
+
+    const QString value = QString::fromLatin1(qgetenv("KRDP_ENABLE_NLA")).trimmed().toLower();
+    return value != QLatin1String("0")
+        && value != QLatin1String("false")
+        && value != QLatin1String("no")
+        && value != QLatin1String("off");
+}
+
 /**
  * FreeRDP callback for the capabilities event.
  */
@@ -183,6 +242,16 @@ BOOL peerActivate(freerdp_peer *peer)
     return FALSE;
 }
 
+BOOL peerLogon(freerdp_peer *peer, const SEC_WINNT_AUTH_IDENTITY *identity, BOOL automatic)
+{
+    auto context = reinterpret_cast<PeerContext *>(peer->context);
+    if (context->connection->onLogon(identity, automatic)) {
+        return TRUE;
+    }
+
+    return FALSE;
+}
+
 BOOL suppressOutput(rdpContext *context, uint8_t allow, const RECTANGLE_16 *)
 {
     auto peerContext = reinterpret_cast<PeerContext *>(context);
@@ -209,6 +278,8 @@ public:
     std::unique_ptr<Clipboard> clipboard;
 
     freerdp_peer *peer = nullptr;
+    bool logonDecisionPresent = false;
+    bool logonAccepted = false;
 
     std::jthread thread;
 };
@@ -349,7 +420,11 @@ void RdpConnection::initialize()
 
     freerdp_settings_set_bool(settings, FreeRDP_RdpSecurity, false);
     freerdp_settings_set_bool(settings, FreeRDP_TlsSecurity, true);
-    freerdp_settings_set_bool(settings, FreeRDP_NlaSecurity, false);
+    // NLA via WinPR SAM can fail on Linux and add a failing pre-auth roundtrip.
+    // Keep it opt-in for clients that explicitly require it.
+    const bool enableNla = nlaEnabledFromEnvironment();
+    freerdp_settings_set_bool(settings, FreeRDP_NlaSecurity, enableNla);
+    qCDebug(KRDP) << "NLA security enabled:" << enableNla;
 
     freerdp_settings_set_uint32(settings, FreeRDP_OsMajorType, OSMAJORTYPE_UNIX);
     // PSEUDO_XSERVER is apparently required for things to work properly.
@@ -389,6 +464,7 @@ void RdpConnection::initialize()
 
     d->peer->Capabilities = peerCapabilities;
     d->peer->Activate = peerActivate;
+    d->peer->Logon = peerLogon;
     d->peer->PostConnect = peerPostConnect;
 
     d->peer->context->update->SuppressOutput = suppressOutput;
@@ -503,38 +579,101 @@ bool RdpConnection::onActivate()
    return true;
 }
 
-bool RdpConnection::onPostConnect()
+bool RdpConnection::onLogon(const SEC_WINNT_AUTH_IDENTITY *identity, BOOL automatic)
 {
-    qCInfo(KRDP) << "New client connected:" << d->peer->hostname << freerdp_peer_os_major_type_string(d->peer) << freerdp_peer_os_minor_type_string(d->peer);
+    QString username;
+    QString password;
 
-    rdpSettings *settings = d->peer->context->settings;
+    if (identity) {
+        const QString user = authIdentityString(identity->User, identity->UserLength);
+        const QString domain = authIdentityString(identity->Domain, identity->DomainLength);
+        password = authIdentityString(identity->Password, identity->PasswordLength);
+        username = domain.isEmpty() ? user : QStringLiteral("%1\\%2").arg(domain, user);
+
+        qCDebug(KRDP) << "Logon callback user:" << username << "automatic:" << (automatic == TRUE) << "passwordLength:" << password.size();
+    } else {
+        qCWarning(KRDP) << "Logon callback did not provide an identity";
     }
 
-    if (!freerdp_settings_set_bool(settings, FreeRDP_AutoLogonEnabled, true)) {
-        return false;
+    // Some clients do not provide credentials here and only send them later.
+    // Defer to PostConnect in that case.
+    if (username.isEmpty() && password.isEmpty()) {
+        qCDebug(KRDP) << "Logon callback had no credentials; deferring authentication to PostConnect";
+        d->logonDecisionPresent = false;
+        d->logonAccepted = false;
+        return true;
+    }
+
+    d->logonAccepted = authenticateLogin(username, password);
+    d->logonDecisionPresent = true;
+    return d->logonAccepted;
+}
+
+bool RdpConnection::authenticateLogin(const QString &rawUsername, const QString &password)
+{
+    const QString username = normalizeLoginName(rawUsername);
+
+    qCDebug(KRDP) << "Authenticating RDP login for user" << rawUsername << "(normalized to" << username << ", passwordLength:" << password.size() << ")";
 
     if (d->server->usePAMAuthentication()) {
         qCDebug(KRDP) << "Attempting authenticating user with PAM";
-        if (username == KUser().loginName() && pamAuthenticate(username, password) >= 0) {
+        if (matchesLoginName(username, KUser().loginName()) && pamAuthenticate(KUser().loginName(), password) >= 0) {
             qCDebug(KRDP) << "PAM authentication succeeded for user" << username;
             return true;
         }
     }
 
     const auto users = d->server->users();
-    for (auto user : users) {
+    for (const auto &user : users) {
         if (user.password.isEmpty()) {
-            return false;
+            qCWarning(KRDP) << "Skipping configured RDP user with empty password:" << user.name;
+            continue;
         }
-        if (user.name == username && user.password == password) {
+        if (matchesLoginName(username, user.name) && user.password == password) {
             qCDebug(KRDP) << "User" << username << "authenticated successfully";
             return true;
         }
     }
 
+    qCWarning(KRDP) << "Authentication failed for user" << rawUsername;
     return false;
 }
 
+bool RdpConnection::onPostConnect()
+{
+    qCInfo(KRDP) << "New client connected:" << d->peer->hostname << freerdp_peer_os_major_type_string(d->peer) << freerdp_peer_os_minor_type_string(d->peer);
+
+    rdpSettings *settings = d->peer->context->settings;
+
+    if (!freerdp_settings_set_bool(settings, FreeRDP_AutoLogonEnabled, true)) {
+        return false;
+    }
+
+    if (d->logonDecisionPresent) {
+        qCDebug(KRDP) << "Using authentication result from Logon callback:" << d->logonAccepted;
+        return d->logonAccepted;
+    }
+
+    QString rawUsername = QString::fromLatin1(freerdp_settings_get_string(settings, FreeRDP_Username));
+    QString password = QString::fromLatin1(freerdp_settings_get_string(settings, FreeRDP_Password));
+
+    // Some clients only expose credentials through the peer identity.
+    if ((rawUsername.isEmpty() || password.isEmpty()) && d->peer->identity.User) {
+        const QString user = authIdentityString(d->peer->identity.User, d->peer->identity.UserLength);
+        const QString domain = authIdentityString(d->peer->identity.Domain, d->peer->identity.DomainLength);
+        const QString identityPassword = authIdentityString(d->peer->identity.Password, d->peer->identity.PasswordLength);
+
+        if (rawUsername.isEmpty()) {
+            rawUsername = domain.isEmpty() ? user : QStringLiteral("%1\\%2").arg(domain, user);
+        }
+        if (password.isEmpty()) {
+            password = identityPassword;
+        }
+    }
+
+    return authenticateLogin(rawUsername, password);
+}
+
 bool RdpConnection::onClose()
 {
     d->clipboard->close();
diff --git a/src/RdpConnection.h b/src/RdpConnection.h
index c84c1a5..ffc1915 100644
--- a/src/RdpConnection.h
+++ b/src/RdpConnection.h
@@ -8,6 +8,7 @@
 #include <thread>
 
 #include <QObject>
+#include <QString>
 
 #include <freerdp/freerdp.h>
 
@@ -103,6 +104,7 @@ private:
     friend BOOL peerCapabilities(freerdp_peer *);
     friend BOOL peerActivate(freerdp_peer *);
     friend BOOL peerPostConnect(freerdp_peer *);
+    friend BOOL peerLogon(freerdp_peer *, const SEC_WINNT_AUTH_IDENTITY *, BOOL);
     friend BOOL suppressOutput(rdpContext *, uint8_t, const RECTANGLE_16 *);
 
     friend class Cursor;
@@ -119,7 +121,9 @@ private:
 
     bool onCapabilities();
     bool onActivate();
+    bool onLogon(const SEC_WINNT_AUTH_IDENTITY *identity, BOOL automatic);
     bool onPostConnect();
+    bool authenticateLogin(const QString &rawUsername, const QString &password);
     bool onClose();
     bool onSuppressOutput(uint8_t allow);
 
diff --git a/src/VideoStream.cpp b/src/VideoStream.cpp
index ee1675d..4e612d9 100644
--- a/src/VideoStream.cpp
+++ b/src/VideoStream.cpp
@@ -313,7 +313,16 @@ uint32_t VideoStream::onCapsAdvertise(const RDPGFX_CAPS_ADVERTISE_PDU *capsAdver
         return CHANNEL_RC_INITIALIZATION_ERROR;
     }
 
+    // Some clients advertise unknown/newer versions. Pick the highest version
+    // only from caps that actually support AVC+YUV420.
     auto maxVersion = std::max_element(capsInformation.begin(), capsInformation.end(), [](const auto &first, const auto &second) {
+        const bool firstSupported = first.avcSupported && first.yuv420Supported;
+        const bool secondSupported = second.avcSupported && second.yuv420Supported;
+
+        if (firstSupported != secondSupported) {
+            return !firstSupported && secondSupported;
+        }
+
         return first.version < second.version;
     });
